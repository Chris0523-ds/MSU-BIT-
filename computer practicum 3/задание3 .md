# 文件和目录的基本操作
## 从目录文件中读取信息
有权读取此目录的程序可从目录文件中读取信息。但是只有内核才能对目录进行写操作，保证了文件系统的安全。 有一组用于处理目录的函数，它是 POSIX.1 标准的一部分。
这类函数，有头文件目录``#include <dirent.h>``
1.```DIR * opendir (const char * pathname);```成功时返回指针，错误时返回 NULL
2.```struct dirent * readdir (DIR * dp);```成功时返回指针，到达目录末尾或出错时返回 NULL
3.```void rewinddir (DIR * dp);```初始化与 dp 关联的目录中的当前位置
4.```int closedir (DIR * dp);```关闭先前打开的目录。成功返回 0 或错误返回 -1
5.```long tell (DIR * dp);```返回与 dp 关联的目录中当前位置的值
6.```void seekdir (DIR * dp, long loc);```允许在与 dp 关联的目录中设置当前位置
dirent 结构在 <dirent.h> 文件中定义并且是特定于实现的。但是，在任何版本的 UNIX 上，此结构至少包含以下两个字段：
```
ino_t d_ino; /* inode编号*/
char d_name []; /* 带有文件名的空终止字符串 */
```
例1 遍历目录树的程序：
```c{.line-numbers}
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
void err_sys(const char* info)
{
 perror(info);
 exit(1);
}
typedef int Myfunc(const char*, const struct stat*, int);
static Myfunc myfunc;
static int myscan(char*, Myfunc*);
static int dopath(Myfunc*);
int main(int argc, char* argv[])
{
    int ret = 0;
    if (argc != 2)
    printf("Usage: scandir <initial directory>\n")
    else
    {
        ret = myscan(argv[1], myfunc); /* performs all work */
        printf("OK\n");
    }
    return ret;
}
#define FILEINFO 1 /* not a directory */
#define DIRINFO 2 /* accessible directory */
#define NODIRINFO 3 /* unaccessible directory */
#define NOFILEINFO 4 /* unknown file type */
static char fullpath[300]; /* full path to each file */
static int myscan(char* initpathname, Myfunc* func)
{
    strcpy(fullpath, initpathname);
    return dopath(func);
}
static int dopath(Myfunc* func)
{
    struct stat statbuf;
    struct dirent* dirp;
    DIR* dp;
    int ret;
    if (lstat(fullpath, &statbuf) < 0) /* stat error */
    return func(fullpath, &statbuf, NOFILEINFO);
    if (S_ISDIR(statbuf.st_mode) == 0) /* not a directory */
    return(func(fullpath, &statbuf, FILEINFO));
    /*
* This is a directory. Call func(),
* then process all files in this directory recursively.
*/
    if ((ret = func(fullpath, &statbuf, DIRINFO)) != 0)
    return ret;
    size_t n = strlen(fullpath);
    fullpath[n++] = '/';
    fullpath[n] = 0;
    if ((dp = opendir(fullpath)) == NULL) /* unaccessible directory */
    return func(fullpath, &statbuf, NODIRINFO);
    while ((dirp = readdir(dp)) != NULL) 
    {
        if (strcmp(dirp->d_name, ".") == 0 ||strcmp(dirp->d_name, "..") == 0)
        continue; /* skip "." и ".." */
        strcpy(&fullpath[n],dirp->d_name); /* add name after slash */
        if ((ret = dopath(func)) != 0) /* recursive call */
        break; /* error */
    }
    fullpath[n - 1] = 0; /* remove right part of the filename */
    if (closedir(dp) < 0)
    err_sys("closedir error");
    return ret;
}
static int myfunc(const char* pathname, const struct stat* statptr, int type)
{
    switch (type) 
    {
    case FILEINFO:
        if (S_ISREG(statptr->st_mode))
        printf("File: ");
        else if (S_ISFIFO(statptr->st_mode))
        printf("FIFO: ");
        else if (S_ISLNK(statptr->st_mode))
        printf("Link: ");
        else if (S_ISSOCK(statptr->st_mode))
        printf("Socket: ");
        break;
    case DIRINFO:
        printf("Dir: ");
        break;
    case NODIRINFO:
        printf("Unaccessible dir: ");
        break;
    default:
        printf("Unknown filetype: ");
    }
printf("%s\n", pathname);
return 0;
}
```
## 第9题题解
题目：当程序启动时，会显示当前目录（或指定为命令行参数的目录）的子目录列表。列出了所有级别的子目录，为每个目录指定了完整路径，从源目录的名称开始）。。
对于此题，我们只需要改变两个函数：main和myfunc。
需要修改main函数是因为task 9中允许不指定命令行参数（此时必须分析当前工作目录），而原程序要求存在参数- 分析目录的名称。
新版本的主函数将如下所示：
```c{.line-numbers}
int main(int argc, char* argv[])
{
    int ret = 0;
    printf("Usage: scandir [<initial directory>]\n");
    if (argc > 2)
    {
        printf("Error: many program arguments\n");
        return 1;
    }
    else
    {
        char* cwdir = (char*)malloc(200);
        ret = myscan(argc == 2 ? argv[1] : getcwd(cwdir, 200),myfunc); /* performs all work */
        printf("OK\n");
    }
    return ret;
}
```
在新版本中，我们首先显示有关正确程序调用的信息（我们通过将<initial directory> 参数括在方括号中来表明它是可选的）。然后我们检查参数的个数，如果超过1个（argc>2的情况），我们打印错误信息并立即退出程序。如果正好有一个参数，那么它（argv [1]）被用作myscan函数的第一个参数；如果没有参数，则使用 getcwd 函数获取的当前目​​录的名称作为 myscan 函数的第一个参数（我们首先为该函数的 cwdir 参数分配内存，该参数也存储名称当前目录）。
作业 9 的 myfunc 函数非常简单：它只是检查该函数是否被调用来处理目录（案例类型 == DIRINFO），并通过打印出完整的目录名称来处理该案例：
```c{.line-numbers}
static int myfunc(const char* pathname, const struct stat* statptr, int type)
{
    if (type == DIRINFO)
    printf("%s\n", pathname);
    return 0;
}
```
其他作业可能需要使用 statptr 参数中包含的信息。 有时您可能需要对 dopath 函数进行一些更改。
## 处理日期和时间
由于该组中的许多作业需要处理日期和时间，因此这里有一个程序演示了标准 C 库提供的大部分相关功能。
```c{.line-numbers}
#include <stdio.h>
#include <time.h>
int main()
{
    time_t tt1;
    struct tm* tm1;
    time(&tt1);
    tm1 = localtime(&tt1);
    // - в структуре time_t значение даты-времени хранится как набор
    // полей, в типе time_t (фактически long int) – как количество секунд,
    // прошедших с определенного момента в прошлом.
    printf("time_t: %ld asctime: %s", tt1, asctime(tm1));
    // - функция asctime возвращает текстовое представление даты-времени
    // в стандартном формате
    char str[100];
    strftime(str, 100, "%Y.%m.%d,%H:%M:%S", tm1);
    // - функция strftime позволяет настраивать
    // текстовое представление даты-времени
    printf("strftime: %s\n", str);
    time_t tt2 = tt1 + 10;
    // - с типом time_t можно выполнять арифметические операции
    struct tm* tm2;
    tm2 = localtime(&tt2);
    // - с помощью функции localtime тип time_t можно преобразовать в tm
    strftime(str, 100, "%Y.%m.%d,%H:%M:%S", tm2);
    printf("strftime (+10 sec): %s\n", str);
    tm2->tm_hour++;
    // - поля структуры tm можно изменять
    strftime(str, 100, "%Y.%m.%d,%H:%M:%S", tm2);
    tt2 = mktime(tm2);
    // - с помощью функции mktime тип tm можно преобразовать в time_t
    printf("time_t: %ld strftime (+1 hour): %s\n", tt2, str);
    printf("difftime: %f %ld\n", difftime(tt2, tt1), tt2 - tt1);
    // - сравнивать значения даты-времени типа time_t
    // можно непосредственно или с помощью функции difftime
    struct tm tm3;
    sscanf(str, "%d.%d.%d,%d:%d:%d",&tm3.tm_year, &tm3.tm_mon, &tm3.tm_mday,&tm3.tm_hour, &tm3.tm_min, &tm3.tm_sec);
    // - для преобразования строки в дату-время стандартной функции
    // не предусмотрено,однако можно использовать функцию sscanf
    tm3.tm_year -= 1900;
    tm3.tm_mon--;
    // - необходимо учитывать особенности представления
    // полей tm_year и tm_mon
    printf("yday = %d\n", tm3.tm_yday);
    // - если структура tm заполняется непосредственно,
    // то поля, не заполненные явно, использовать не следует
    time_t tt3 = mktime(&tm3);
    // - для получения правильного значения типа time_t из структуры tm
    // достаточно заполнить в этой структуре поля
    // для года, месяца, дня месяца, часа, минуты и секунды
    strftime(str, 100, "%Y.%m.%d,%H:%M:%S", &tm3);
    printf("restored values: %ld %s\n", tt3, str);
    struct tm* tm3a = localtime(&tt3);
    printf("yday = %d\n", tm3a->tm_yday);
    // - для восстановления всех полей структуры tm достаточно выполнить
    // двойное преобразование: tm в time_t и обратно time_t в tm
return 0;
}

```
下面是这个程序的输出示例：
```
time_t: 1631930426 asctime: Sat Sep 18 10:00:26 2021
strftime: 2021.09.18,10:00:26
strftime (+10 sec): 2021.09.18,10:00:36
time_t: 1631934036 strftime (+1 hour): 2021.09.18,11:00:36
difftime: 3610.000000 3610
yday = 0
restored values: 1631934036 2021.09.18,11:00:36
yday = 260
```
我们还记得上次修改文件的时间信息包含在```stat```结构的```struct timespec st_mtim```字段中，```timespec```类型有一个```time_t```类型的```v​​_sec```字段，可以让你准确的确定指定的时间一秒钟。